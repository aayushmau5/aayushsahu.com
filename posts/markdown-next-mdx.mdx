---
title: "Using MDX with NextJS"
description: "How to use MDX with NextJS?"
date: 2022-01-20T07:27:46.681Z
tags: ["mdx", "nextjs", "markdown"]
cover:
	image: "/blogImages/"
	alt: ""
	caption: ""
draft: true
---

# Introduction

**MDX** is a markdown extension that brings in support for JS components(typically react components, but not only limited to) inside markdown.

Here's what I did to use MDX with NextJS.

To know more about MDX, checkout the official MDX docs [here](https://mdxjs.com/docs/getting-started/).

# Goal

My main goal was to:

- Get MDX working
- Integrate remark/rehype plugins for syntax highlighting, heading links, generating slugs, etc.
- Using custom react components inside my blogs
- Since all my posts are in a `posts/` directory, I want this directory to be the source(I don't like mixing up JS and MDX files).

# Using MDX with NextJS

The idea of using MDX in my blogs came from [this article](https://www.joshwcomeau.com/blog/how-i-built-my-blog/) by [Josh W Comeau](https://www.joshwcomeau.com/) (ðŸ™ thanks, Josh).

As it turns out, there are multiple libraries that allows us to use MDX with NextJS. Some of them are(based on popularity/usage):

- `@next/mdx`
- `mdx-bundler`
- `next-mdx-enhanced` (**deprecated**, maintainers now recommend `next-mdx-remote`)
- `next-mdx-remote`

I was pretty confused as to which library should I use. [This article](https://dev.to/tylerlwsmith/quick-comparison-of-mdx-integration-strategies-with-next-js-1kcm) compares these libraries pretty well.

> There's no "the best" solution out there. Just use the one you feel like going with, and if you face any problems in the way, try to fix it or switch to other solution.

With some struggles, I chose `next-mdx-remote`.

<HiddenExpand summary="My struggle with @next/mdx">

At first, I was not sure which library to go with. So, I started with `@next/mdx`, but things kinda started going wrong. See how ðŸ‘‡

**Trying `@next/mdx`**

I basically followed [this guide](https://nextjs.org/docs/advanced-features/using-mdx) to setup MDX. In order to use MDX with NextJS, we have to modify the NextJS config file `next.config.js`.

Install the `@next/mdx` library using

```
npm i @next/mdx
```

Then modify `next.config.js` as below.

```js
// next.config.js
const withMDX = require("@next/mdx")();
module.exports = withMDX();

// OR

const withMDX = require("@next/mdx")({
  extension: /\.(md|mdx)$/,
});

module.exports = withMDX({
  pageExtensions: ["js", "jsx", "md", "mdx", "ts", "tsx"],
});
```

After making the changes, I went ahead and made a `.mdx` file inside the `/pages` directory. And it worked!

**The problem**

I use `remark` plugins in order to have syntax highlighting, heading links, generating slugs, etc. And these remark plugins are ESM only(i.e. they use `import` instead of `require`), and I couldn't use `import` statements inside `next.config.js`.

I did manage to workaround this problem by having `"type": "module"` in `package.json` and rename `next.config.js` to `next.config.mjs`.

Now my `next.config.mjs` looks like this:

```js
import rehypeSlug from "rehype-slug";
import remarkToc from "remark-toc";
import NextMdx from "@next/mdx";

const withMDX = NextMdx({
  extension: /\.(md|mdx)$/,
  options: {
    remarkPlugins: [remarkToc],
    rehypePlugins: [rehypeSlug],
  },
});

export default withMDX({
  pageExtensions: ["md", "tsx"],
});
```

This didn't help because I started getting webpack warnings with remark plugins, and some plugins refused to work, and the internet didn't help ðŸ˜ž

![Remark plugin error](/blogImages/markdown-next-mdx/webpack-error.png)

And with that, my journey with `@next/mdx` ended.

</HiddenExpand>

# Using `next-mdx-remote`

I looked at [this example](https://github.com/vercel/next.js/tree/canary/examples/with-mdx-remote) to get a general idea of using `next-mdx-remote`. I recommend you check out that example as well.

## Directory Structure

```
posts/
â”œâ”€â”€ blog1.mdx
â””â”€â”€ blog2.mdx
pages/
â”œâ”€â”€ blog/
â”‚   â”œâ”€â”€ index.js
â”‚   â””â”€â”€ [slug].js
â””â”€â”€ index.js
utils/
â””â”€â”€ getPostData.js
```

Like I said, the `posts/` directory contains all my `mdx` blogs, and `utils/getPostData.js` contains some utility functions. We will see what those utility functions are, later.

As we already know, `pages/blog/index.js` points to `/blog` route & `pages/blog/[slug].js` is a dynamic route which will point to anything that comes after `/blog`, for example, `/blog/something`.

The point being, `/blog` route will have the index of all blogs, and the dynamic route will point to a specific blog(identified by the `slug`) which is a MDX blog.

## Steps

Install the following packages

```
npm i next-mdx-remote gray-matter
```

One thing to note about `next-mdx-remote` is that it doesn't care about where your data comes from, all it needs is that you provide the data. Like I said earlier, all my MDX blogs are inside a `posts/` directory, so we need to perform some kind of operation in order to provide `next-mdx-remote` my MDX blogs from `posts/` directory.

We will create some utility functions that will:

- get all the **sorted** posts data(like the contents, and frontmatter). This will be used in `/blog` route to index all the blogs.
- get all the post id.
- get post contents corresponding to their `slug`.

For this, we will read all the mdx files from `posts/` directory, parse their frontmatter using the [gray-matter library](https://www.npmjs.com/package/gray-matter).

Here's the code:

```js
// utils/getPostData.js
import fs from "fs";
import path from "path";
import matter from "gray-matter";

const postsDirectory = path.join(process.cwd(), "posts"); // the posts/ directory path
const fileNames = fs.readdirSync(postsDirectory); // all the mdx files inside the posts/ directory

// sorted post data
export function getSortedPostsData() {
  const allPostsData = fileNames.map((fileName) => {
    const slug = fileName.replace(/\.mdx$/, ""); // remove the .mdx extension from file names

    const fullPath = path.join(postsDirectory, fileName);
    const fileContents = fs.readFileSync(fullPath, "utf-8"); // read the file contents

    const { data: frontMatter } = matter(fileContents); // get the frontmatter

    return {
      slug,
      ...frontMatter,
    };
  });

  // sort the posts
  return allPostsData.sort((a, b) => {
    if (a.date < b.date) {
      return 1;
    } else {
      return -1;
    }
  });
}

// all post ids(or slug)
export function getAllPostIds() {
  const fileNames = fs.readdirSync(postsDirectory);
  return fileNames.map((fileName) => ({
    params: {
      slug: fileName.replace(/\.mdx$/, ""),
    },
  }));
}

// a particular post data
export async function getPostData(slug) {
  const fullPath = path.join(postsDirectory, `${slug}.mdx`); // get the full path of a post
  const fileContents = fs.readFileSync(fullPath, "utf-8"); // read the post contents

  const matterResult = matter(fileContents);

  return {
    slug,
    content: matterResult.content, // the file contents without the frontmatter
    frontmatter: matterResult.data, // the frontmatter
  };
}
```

After this, first we will index all the blogs inside `/blogs` route. For this, put the following code in `pages/blog/index.js` file.

```jsx
// /pages/blog/index.js
import { getSortedPostsData } from "utils/getPostData";

export default function Blogs({ posts }) {
  // maps through the blog posts
  return (
    <div>
      {posts.map((post, index) => (
        <Link key={index} href={`/blog/${post.slug}`}>
          <a>{post.title}</a>
        </Link>
      ))}
    </div>
  );
}

export const getStaticProps = () => {
  const posts = getSortedPostsData(); // get all the sorted posts data

  return {
    props: {
      // pass it to the component through props
      posts,
    },
  };
};
```

That's it. We are using the `getSortedPostsData` utility function to get all the sorted posts, and then rendering it on the page.

One cool thing about this is, we are statically generating the data using `getStaticProps`, meaning all the data will be generated at built time, and you will have a static website. More info about `getStaticProps` [here](https://nextjs.org/docs/basic-features/data-fetching/get-static-props).

Now that we have an index page, users can click on any of the link, and they will be directed to `/blog/<blog-slug>` route, which will be handled by our `/pages/blog/[slug].js` code.

Here's the code for that:

```jsx
// /pages/blog/[slug].js
import { serialize } from "next-mdx-remote/serialize";
import { MDXRemote } from "next-mdx-remote";

import { getAllPostIds, getPostData } from "utils/getPosts";

export default function BlogPost({ source }) {
  // render the MDX blog
  return (
    <div>
      <MDXRemote {...source} />
    </div>
  );
}

export const getStaticPaths = async () => {
  const paths = getAllPostIds(); // all the posts slug
  return {
    paths,
    fallback: false,
  };
};

export const getStaticProps = async ({ params }) => {
  const { content } = await getPostData(params.slug); // the post data in string
  const mdxSource = await serialize(content); // parse the MDX string
  return { props: { source: mdxSource } };
};
```

Let's start with [`getStaticPaths`](https://nextjs.org/docs/basic-features/data-fetching/get-static-paths) first. Using `getStaticPaths` we define a list of paths that we want to be statically generated. Thus, we are passing all the blog slugs so that our blogs can be statically generated.

Now, onto `getStaticProps`, the blog we want to access will be passed to the `slug` property in `params` object. Using that slug, we get the post data using `getPostData` function. This post data is just our MDX blog in a string format.

We then pass the MDX string to `serialize` function which we are importing from `next-mdx-remote/serialize`. This function parses and compiles the provided MDX string and, returns a result which can be passed into a component to be rendered. The compiled MDX is then passed to our `BlogPost` component through the `props`(The return value from `getStaticProps` is passed to the rendering component).

Inside our `BlogPost` component, we are using the `MDXRemote` component imported from `next-mdx-remote` whose job is to render the compiled source that we are getting from the props.

That's it. Start the nextjs dev server, and go to `/blog`, we will see the list of blogs. And on going to certain blog, we will see the rendered MDX blog.

## Using remark/rehype plugins

Now that we have setup MDX, it's time to use Remark/Rehype pulgins. These plugins can be used to provide syntax highlighting, have autolinks in headings, generate table of contents, etc.

We will use `rehype-prism-plus` to provide syntax highlighting, and `remark-toc` to generate Table of Contents.

```
npm i rehype-prism-plus remark-toc
```

Since remark/rehype plugins only support ESM modules, we can use it inside our `/pages/blog/[slug].js` file.

Here's the code:

```jsx
// /pages/blog/[slug].js
import { serialize } from "next-mdx-remote/serialize";
import { MDXRemote } from "next-mdx-remote";

import rehypePrism from "rehype-prism-plus";
import remarkToc from "remark-toc";

import { getAllPostIds, getPostData } from "utils/getPosts";

export default function BlogPost({ source }) {
  // render the MDX blog
  return (
    <div>
      <MDXRemote {...source} />
    </div>
  );
}

export const getStaticPaths = async () => {
  const paths = getAllPostIds(); // all the posts slug
  return {
    paths,
    fallback: false,
  };
};

export const getStaticProps = async ({ params }) => {
  const { content } = await getPostData(params.slug); // the post data in string
  const mdxSource = await serialize(content, {
    mdxOptions: {
      rehypePlugins: [
        // passing rehype plugins(in an array)
        [rehypePrism, { showLineNumbers: true }], // to pass options to plugins, put the plugin in an array, and 2nd element should be the options
      ],
      remarkPlugins: [remarkToc], // passing remark plugins
    },
  }); // parse the MDX string, now with pulgins
  return { props: { source: mdxSource } };
};
```

Everything remains the same except the part where we are parsing and compiling the MDX string. The `serialize` function takes a second parameter, which is a config object. In this config object, we are providing `mdxOptions` which is another object in which we pass remark and rehype plugins separately.

One thing to know that is these plugins are used during the compilation of our MDX blog. That's why they are passed as options to the `serialize` function.

And with that, we should have our plugin working.

## Using custom react components

One of MDX's prominent feature is to use React components inside your blogs, and It would be a shame if we didn't this feature. So, let's use some React components inside our blogs.

Here's an example blog using a component that will take a heading prop, and a children to show the contents inside it.

Take a look at the MDX syntax

```md
---
title: "Using MDX with NextJS"
description: "How to use MDX with NextJS?"
---

<ShowContentInside title="">

</ShowContentInside>
```

```jsx
function ShowContentInside({ title, children }) {
  return (
    <div>
      <h1>{title}</h1>
      <div>{children}</div>
    </div>
  );
}
```

## Concerns

- Bundle size & the solution with dynamic importing way
  Reading about `next-mdx-remote`, it turns out that all the components are bundled during build time and It is available to every MDX file.
  Though one can use dynamic importing and some clever hack to dynamically import heavy components.
  See more at: https://github.com/hasicorp/next-mdx-enhanced/issues/103
- HMR
  Use this to get realtime HMR thing: https://github.com/hashicorp/next-remote-watch
  https://nextjs.org/docs/advanced-features/preview-mode
  Preview mode doesn't work due to 2kb limit and much more work to setup.
- Per page bundle size

# `mdx-bundler`

ðŸ¤”
I never looked into `mdx-bundler` but it seemed to have all the goodies to use MDX. And it is framework agnostic, so you can use it with anything else.
